;;; Adaptive fill
;;; Copyright (C) 1989 Kyle E. Jones
;;;
;;; This program is free software; you can redistribute it and/or modify
;;; it under the terms of the GNU General Public License as published by
;;; the Free Software Foundation; either version 1, or (at your option)
;;; any later version.
;;;
;;; This program is distributed in the hope that it will be useful,
;;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;;; GNU General Public License for more details.
;;;
;;; A copy of the GNU General Public License can be obtained from this
;;; program's author (send electronic mail to kyle@cs.odu.edu) or from
;;; the Free Software Foundation, Inc., 675 Mass Ave, Cambridge, MA
;;; 02139, USA.
;;;
;;; Send bug reports to kyle@cs.odu.edu.

;; These functions enhance the default behavior of the Emacs'
;; auto-fill-mode and the command fill-paragraph.  The chief improvement
;; is that the beginning of a line to be filled is examined and
;; appropriate values for fill-prefix, and the various paragraph-*
;; variables are constructed and used during fills.  This occurs only if
;; the fill prefix is not already non-nil.
;;
;; The net result of this is that blurbs of text that are offset from
;; left margin by asterisks, dashes, and/or spaces, numbered examples,
;; included text from USENET news articles, etc. are generally filled
;; correctly with no fuss.
;;
;; Since this package replaces two existing Emacs functions, it cannot
;; be autoloaded.  Save this in a file named filladapt.el in a Lisp
;; directory that Emacs knows about, byte-compile it and put
;;    (require 'filladapt)
;; in your .emacs file.

;;; Modification history:
;;;  1. 8/11/94 alarson@src.honeywell.com
;;;     Misc fixes to better handle leading whitespace, and make handling
;;;     of comments more generic.
;;;  2. 12/7/94  Get forward/backward paragraph to work better with
;;;     indented/commented text.  Introduce functions filladapt-forward/
;;;     backward paragraph.  Recommended bindings:
;;;      (define-key text-mode-map "\M-\C-a" 'filladapt-backward-paragraph)
;;;      (define-key text-mode-map "\M-\C-e" 'filladapt-forward-paragraph)

(provide 'filladapt)

(defvar filladapt-prefix-table
  '(
    ;; Included text in news or mail replies
    ("\\s *\\(>+\\s *\\)+" . filladapt-normal-included-text)
    ;; Included text generated by SUPERCITE.  We can't hope to match all
    ;; the possible variations, your mileage may vary.
    ("[^'`\"< \t]*>\\s *" . filladapt-supercite-included-text)
    ;; Lists with hanging indents, e.g.
    ;; 1. xxxxx   or   *   xxxxx   etc.
    ;;    xxxxx            xxx
    ("\\s *\\s<*\\s *\\((?\\([0-9]+[a-z]?\\|[a-z]\\))\\)\\s +" . filladapt-hanging-list)
    ("\\s *\\s<*\\s *\\([0-9]+[a-z]?\\|[a-z]\\)\\.\\s +" . filladapt-hanging-list)
    ("\\s *\\s<*\\s *\\([?!~*+o-]+\\)\\s +" . filladapt-hanging-list)
    ;; Lisp, postscript, shell, etc comments.  Must be in the right mode
    ;; for them to work! 
    ("\\s *\\(\\s<+\\s *\\)+" . filladapt-line-oriented-comment)
    ;; C++ comments
    ("\\s *//[/ \t]*" . filladapt-c++-comment)
    ;; This should be the last guy, it will always match, and handles non
    ;; indented paragraphs as a special case.
    ("\\s *\\s<*\\s *" . filladapt-normal)
    )
"Value is an alist of the form

   ((REGXP . FUNCTION) ...)

When fill-paragraph or do-auto-fill is called, the REGEXP of each alist
element is compared with the beginning of the current line.  If a match is
found the crorrespoding FUNCTION, of no arguments, is called.  FUNCTION
should return a list:

   (fill-prefix paragraph-start)

Where fill-prefix is the desired fill-prefix, and paragraph-start is T if
the regexp indicates that this is the first line of a paragraph (e.g., it
is the first line of a numbered item list, or \\item in LaTeX).")

(defvar filladapt-function-table
  (list (cons 'fill-paragraph (symbol-function 'fill-paragraph))
	(cons 'do-auto-fill (symbol-function 'do-auto-fill)))
  "Table containing the old function definitions that filladapt usurps.")

(defun filladapt-funcall (function &rest args)
  (apply (cdr (assoc function filladapt-function-table)) args))

(defun filladapt-adapt ()
  "Return the regexp in the filladapt-prefix-table matching the current line,
or nil if there is no such match."
  (let ((table filladapt-prefix-table)
	case-fold-search
	success )
    (save-excursion
      (beginning-of-line)
      (while table
	(if (not (looking-at (car (car table))))
	    (setq table (cdr table))
	  (let ((result (funcall (cdr (car table)))))
	    (if (not (consp result))
		(error "Filladapt function %s returned illegal result."
		       (cdr (car table))))
	    (setq success result
		  table nil)))))
    success))

(defun filladapt-paragraph-start-p ()
  "True if the current line matches paragraph-start, or if any of the
filladapt-prefix-table functions indicate that the current line is the
first line of a paragraph.  Indentation of surrounding lines is not
examined in order to determine if the current line is the start of a
paragraph."
  (cond
   ((save-excursion (beginning-of-line) (looking-at paragraph-start)))
   (t
    (car (cdr (filladapt-adapt))))))

(defun filladapt-current-line-fill-prefix ()
  (car (filladapt-adapt)))

(defun filladapt-normal-included-text ()
  (list (buffer-substring (match-beginning 0) (match-end 0))))

(defun filladapt-supercite-included-text ()
  (list (buffer-substring (match-beginning 0) (match-end 0))))  

(defun filladapt-line-oriented-comment ()
  (list (buffer-substring (match-beginning 0) (match-end 0))))

(defun filladapt-c++-comment ()
  (list (buffer-substring (match-beginning 0) (match-end 0))))

(defun filladapt-normal ()
  (list (buffer-substring (match-beginning 0) (match-end 0))))

(defun filladapt-hanging-list ()
  ;; Assumes matching regexp is of the form " *\\(...\\) *", where the
  ;; stuff in parens is the part which should be left hanging out, and
  ;; should actually contain something other than whitespace.
  ;; make this work with matches including tabs. [alarson:19940811.1705CST]
  (list (concat (buffer-substring (match-beginning 0)
				  (match-beginning 1))
		(make-string (filladapt-string-width
			      (buffer-substring (match-beginning 1)
						(match-end 0))
			      (save-excursion (goto-char (match-beginning 1))
					      (current-column)))
			     ?\ ))
	t))


(defun do-auto-fill ()
  (if (null fill-prefix)
      ;; It seams to me that if you have a fill prefix set, then
      ;; comment-multi-line should have no effect, but it does.  I think
      ;; this is a bug. [alarson:19940826.1854CST]
      (let ((comment-multi-line t)
	    (fill-prefix (filladapt-current-line-fill-prefix)))
	(filladapt-funcall 'do-auto-fill))
      (filladapt-funcall 'do-auto-fill)))

(defun fill-paragraph (arg)
  (interactive "P")
  (if fill-prefix
      (filladapt-funcall 'fill-paragraph arg)
    (save-restriction
      (let (beg end)
	(save-excursion
	  (filladapt-forward-paragraph)
	  (setq end (point))
	  (filladapt-backward-paragraph)
	  (setq beg (point)))
	(narrow-to-region beg end)
	(let ((fill-prefix (filladapt-current-line-fill-prefix)))
	  (filladapt-funcall 'fill-paragraph arg))))))


;;; [alarson:19940826.1703CST]
(defun filladapt-string-width (str &optional starting-column)
  "Returns the number of columns taken up by STRING.
In the absense of tabs, this is the same as the length of STRING.  If
STRING includes tabs, then they are expanded as if the string appeared at
column position STARTING-COLUMN (which defaults to 0)."
  (if (null starting-column) (setq starting-column 0))
  (let ((i 0)
	(width starting-column)
	(str-len (length str)))
    (while (< i str-len)
      (setq width (+ width
		     (if (char-equal ?\t (aref str i))
			 (- tab-width (mod width tab-width))
			 1))
	    i (+ 1 i)))
    (- width starting-column)))

;;; I think These guys now work for lines which have the same indentation,
;;; but don't have exactly the same mix of tabs/spaces.  These funs should
;;; probably be added to the filladapt-function-table and set up to
;;; redefine the originals. [alarson:19941207.1129CST]

(defun filladapt-backward-paragraph (&optional arg)
  (interactive "p")
  (or arg (setq arg 1))
  ;; Assume fill-prefix is nil.
  (while (and (> arg 0) (not (bobp)))
    (setq arg (- arg 1))
    (if (or (bolp)
	    (filladapt-paragraph-start-p))
	(forward-line -1)
      (beginning-of-line))       
    ;; Skip paragraph-separators
    (while (and (not (bobp))
		(looking-at paragraph-separate))
      (forward-line -1))
    ;; Skip backward over any lines where the indentation
    ;; indicates they are part of the same paragaph.
    (let ((indentation-matches t)
	  (fill-prefix (filladapt-current-line-fill-prefix)))
      (while (and (not (bobp))
		  (setq indentation-matches
			(equal fill-prefix
			       (filladapt-current-line-fill-prefix)))
		  (not (filladapt-paragraph-start-p)))
	(forward-line -1))
      (if (not indentation-matches)
	  ;; We went to far...
	  (forward-line 1)))))

(defun filladapt-forward-paragraph (&optional arg)
  (interactive "p")
  (or arg (setq arg 1))
  ;; Assume fill-prefix is nil.
  (if (< arg 0)
      (filladapt-backward-paragraph (- arg))
    (while (and (> arg 0) (not (eobp)))
      (setq arg (- arg 1))
      (beginning-of-line)
      ;; Skip paragraph-separators
      (while (and (not (eobp))
		  (looking-at paragraph-separate))
	(forward-line 1))
   
      ;; Skip over paragraph body
      (let ((prefix (filladapt-current-line-fill-prefix)))
	(forward-line)
	(while (and (not (eobp))
		    (equal prefix (filladapt-current-line-fill-prefix))
		    (not (filladapt-paragraph-start-p)))
	  (forward-line 1))))))

(defvar fill-paragraph-by-first-line-marker (make-marker))

(defun fill-paragraph-by-first-line (arg)
  "Fill paragraph, using first line to decide what the fill-prefix is."
  (interactive "P")
  (let (beginning end)
    (set-marker fill-paragraph-by-first-line-marker (point))
    (forward-paragraph 1)
    (skip-chars-backward "\n")
    (setq end (point))
    (backward-paragraph 1)
    (skip-chars-forward "\n")
    (subst-char-in-region (point) end ?\n ?\ )
    (fill-paragraph arg)
    (goto-char (marker-position fill-paragraph-by-first-line-marker))
    (set-marker fill-paragraph-by-first-line-marker nil)))
